/*
 * mulxp_hash
 * Copyright 2020-2022 Peter Dimov
 * Copyright (C) 2025 Frank J. T. Wojcik
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and
 * to prepare derivative works of the Software, and to permit third-parties
 * to whom the Software is furnished to do so, all subject to the
 * following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole or
 * in part, and all derivative works of the Software, unless such copies or
 * derivative works are solely in the form of machine-executable object
 * code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 * WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "Platform.h"
#include "Hashlib.h"
#include "Mathmult.h"

//------------------------------------------------------------
// Utility functions

FORCE_INLINE uint64_t mulx( uint64_t x, uint64_t y ) {
    uint64_t r, r2;
    MathMult::mult64_128(r, r2, x, y);
    return r ^ r2;
}

inline uint64_t mul32( uint32_t x, uint32_t y ) {
    return (uint64_t)x * y;
}

template <bool bswap>
inline uint64_t read64le( unsigned char const * p ) {
    uint64_t r = GET_U64<bswap>(p, 0);
    return r;
}

template <bool bswap>
inline uint32_t read32le( unsigned char const * p ) {
    uint32_t r = GET_U32<bswap>(p, 0);
    return r;
}

//------------------------------------------------------------
// mulxp1, 32-bit

template <bool bswap>
inline uint32_t mulxp1_hash32( unsigned char const * p, size_t n, uint64_t seed )
{
    uint32_t const q = 0x9e3779b9U;
    uint32_t const k = q * q;

    uint64_t h = ( seed + q ) * k;
    uint32_t w = (uint32_t)h;

    h ^= n;

    while( n >= 4 )
    {
        uint32_t v1 = read32le<bswap>( p );

        w += q;
        h ^= mul32( v1 + w, k );

        p += 4;
        n -= 4;
    }

    {
        uint32_t v1 = 0;

        if( n >= 1 )
        {
            size_t const x1 = ( n - 1 ) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;        // 1: 0, 2: 1, 3: 1

            v1 = (uint32_t)p[ x1 ] << x1 * 8 | (uint32_t)p[ x2 ] << x2 * 8 | (uint32_t)p[ 0 ];
        }

        w += q;
        h ^= mul32( v1 + w, k );
    }

    w += q;
    h ^= mul32( (uint32_t)h + w, (uint32_t)(h >> 32) + w + k );

    return (uint32_t)h ^ (uint32_t)(h >> 32);
}

//------------------------------------------------------------
// mulxp1, 64-bit

template <bool bswap>
inline uint64_t mulxp1_hash( unsigned char const * p, size_t n, uint64_t seed ) {
    uint64_t const q = UINT64_C(0x9e3779b97f4a7c15);
    uint64_t const k = q * q;

    uint64_t w = mulx( seed + q, k );
    uint64_t h = w ^ n;

    while( n >= 8 ) {
        uint64_t v1 = read64le<bswap>( p );

        w += q;
        h ^= mulx( v1 + w, k );

        p += 8;
        n -= 8;
    }

    {
        uint64_t v1 = 0;

        if( n >= 4 )
        {
            v1 = (uint64_t)read32le<bswap>( p + n - 4 ) << ( n - 4 ) * 8 | read32le<bswap>( p );
        }
        else if( n >= 1 )
        {
            size_t const x1 = ( n - 1 ) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;        // 1: 0, 2: 1, 3: 1

            v1 = (uint64_t)p[ x1 ] << x1 * 8 | (uint64_t)p[ x2 ] << x2 * 8 | (uint64_t)p[ 0 ];
        }

        w += q;
        h ^= mulx( v1 + w, k );
    }

    return mulx( h + w, k );
}

//------------------------------------------------------------
// mulxp3, 32-bit

template <bool bswap>
inline uint32_t mulxp3_hash32( unsigned char const * p, size_t n, uint64_t seed )
{
    uint32_t const q = 0x9e3779b9U;
    uint32_t const k = q * q;

    uint64_t h = ( seed + q ) * k;
    uint32_t w = (uint32_t)h;

    h ^= n;

    while( n >= 8 )
    {
        uint32_t v1 = read32le<bswap>( p + 0 );
        uint32_t v2 = read32le<bswap>( p + 4 );

        w += q;
        h ^= mul32( v1 + w, v2 + w + k );

        p += 8;
        n -= 8;
    }

    {
        uint32_t v1 = 0;
        uint32_t v2 = 0;

        if( n >= 4 )
        {
            v1 = read32le<bswap>( p );
            v2 = ((uint64_t)read32le<bswap>( p + n - 4 ) << ( n - 4 ) * 8) >> 32;
        }
        else if( n >= 1 )
        {
            size_t const x1 = ( n - 1 ) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;        // 1: 0, 2: 1, 3: 1

            v1 = (uint32_t)p[ x1 ] << x1 * 8 | (uint32_t)p[ x2 ] << x2 * 8 | (uint32_t)p[ 0 ];
        }

        w += q;
        h ^= mul32( v1 + w, v2 + w + k );
    }

    w += q;
    h ^= mul32( (uint32_t)h + w, (uint32_t)(h >> 32) + w + k );

    return (uint32_t)h ^ (uint32_t)(h >> 32);
}

//------------------------------------------------------------
// mulxp3, 64-bit

template <bool bswap>
inline uint64_t mulxp3_hash( unsigned char const * p, size_t n, uint64_t seed )
{
    uint64_t const q = 0x9e3779b97f4a7c15ULL;
    uint64_t const k = q * q;

    uint64_t w = mulx( seed + q, k );
    uint64_t h = w ^ n;

    while( n >= 16 )
    {
        uint64_t v1 = read64le<bswap>( p + 0 );
        uint64_t v2 = read64le<bswap>( p + 8 );

        w += q;
        h ^= mulx( v1 + w, v2 + w + k );

        p += 16;
        n -= 16;
    }

    {
        uint64_t v1 = 0;
        uint64_t v2 = 0;

        if( n > 8 )
        {
            v1 = read64le<bswap>( p );
            v2 = read64le<bswap>( p + n - 8 ) >> ( 16 - n ) * 8;
        }
        else if( n >= 4 )
        {
            v1 = (uint64_t)read32le<bswap>( p + n - 4 ) << ( n - 4 ) * 8 | read32le<bswap>( p );
        }
        else if( n >= 1 )
        {
            size_t const x1 = ( n - 1 ) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;        // 1: 0, 2: 1, 3: 1

            v1 = (uint64_t)p[ x1 ] << x1 * 8 | (uint64_t)p[ x2 ] << x2 * 8 | (uint64_t)p[ 0 ];
        }

        w += q;
        h ^= mulx( v1 + w, v2 + w + k );
    }

    return mulx( h, k );
}

//------------------------------------------------------------

template <bool bswap>
static void mulxp1_32( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint32_t hash = mulxp1_hash32<bswap>((const unsigned char *)in, len, (uint64_t) seed);
    PUT_U32<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp1_64( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint64_t hash = mulxp1_hash<bswap>((const unsigned char *)in, len, (uint64_t) seed);
    PUT_U64<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp3_32( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint32_t hash = mulxp3_hash32<bswap>((const unsigned char *)in, len, (uint64_t) seed);
    PUT_U32<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp3_64( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint64_t hash = mulxp3_hash<bswap>((const unsigned char *)in, len, (uint64_t) seed);
    PUT_U64<bswap>(hash, (uint8_t *)out, 0);
}

//------------------------------------------------------------
REGISTER_FAMILY(mulxp,
   $.src_url    = "https://github.com/pdimov/mulxp_hash",
   $.src_status = HashFamilyInfo::SRC_STABLEISH
 );

REGISTER_HASH(mulxp1_hash32,
   $.desc            = "mulxp1_hash, 32-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY              ,
   $.bits            = 32,
   $.verification_LE = 0x59CBE0F0,
   $.verification_BE = 0x13253F14,
   $.hashfn_native   = mulxp1_32<false>,
   $.hashfn_bswap    = mulxp1_32<true>
 );

REGISTER_HASH(mulxp1_hash,
   $.desc            = "mulxp1_hash, 64-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY_64_64        ,
   $.bits            = 64,
   $.verification_LE = 0xA476BA89,
   $.verification_BE = 0xA2443FAE,
   $.hashfn_native   = mulxp1_64<false>,
   $.hashfn_bswap    = mulxp1_64<true>
 );

REGISTER_HASH(mulxp3_hash32,
   $.desc            = "mulxp3_hash, 32-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY              ,
   $.bits            = 32,
   $.verification_LE = 0x8C944400,
   $.verification_BE = 0x2B053E73,
   $.hashfn_native   = mulxp3_32<false>,
   $.hashfn_bswap    = mulxp3_32<true>
 );

REGISTER_HASH(mulxp3_hash,
   $.desc            = "mulxp3_hash, 64-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY_64_64        ,
   $.bits            = 64,
   $.verification_LE = 0xB4786096,
   $.verification_BE = 0x0F21A9C4,
   $.hashfn_native   = mulxp3_64<false>,
   $.hashfn_bswap    = mulxp3_64<true>
 );
